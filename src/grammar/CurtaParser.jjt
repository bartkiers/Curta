options {
  STATIC=false;
  OUTPUT_DIRECTORY="src/main/curta";
  NODE_DEFAULT_VOID=true;
  NODE_CLASS="CurtaNode";
}

PARSER_BEGIN(CurtaParser)

package curta;

public class CurtaParser {
}

PARSER_END(CurtaParser)

/**
 * Lexer rules
 */
TOKEN :
{
     < EOS        : ";" | "\r\n" | "\n" | "\r" >
  |  < OParen     : "(" >
  |  < CParen     : ")" >
  |  < Assign     : "=" >
  |  < Or         : "||" >
  |  < And        : "&&" >
  |  < Add        : "+" >
  |  < Sub        : "-" >
  |  < Mul        : "*" >
  |  < Div        : "/" >
  |  < Mod        : "%" >
  |  < GTE        : ">=" >
  |  < GT         : ">" >
  |  < LTE        : "<=" >
  |  < LT         : "<" >
  |  < Eq         : "==" >
  |  < NEq        : "!=" >
  |  < Not        : "!" >
  |  < Comma      : "," >
  |  < True       : "true" >
  |  < False      : "false" >
  |  < Return     : "return" >
  |  < Number     : (<Digit>)+ ("." (<Digit>)+)? | "." (<Digit>)+ >
  |  < Identifier : ("_" | <Letter>) ("_" | <AlphaNum>)* >
}

TOKEN :
{
     < #Digit    : ["0"-"9"] >
  |  < #Letter   : ["a"-"z","A"-"Z"] >
  |  < #AlphaNum : <Letter> | <Digit> >
}

SKIP :
{
     " " 
  |  "\t"
}

/**
 * Parser rules javacc options
 */
protected CurtaNode ast() #Root :
{}
{
  (<EOS>)* statements() <EOF> {return jjtThis;}
}

private void statements() :
{}
{
  (LOOKAHEAD(2) assignment() (<EOS>)+)* ret()
}

private void ret() #Return :
{}
{
  (<Return>)? expr() (<EOS>)*
}

private void assignment() #Assign :
{}
{
  id() <Assign> expr()
}

private void expr() :
{}
{
  or()
}

private void or() :
{}
{
  and() ( <Or> and() #Or(2)
        )*
}

private void and() :
{}
{
  equality() ( <And> equality() #And(2)
             )*
}

private void equality() :
{}
{
  relational() ( <Eq>  relational() #Eq(2)
               | <NEq> relational() #NEq(2)
               )*
}

private void relational() :
{}
{
  add() ( <GTE> add() #GTE(2)
        | <LTE> add() #LTE(2)
        | <GT>  add() #GT(2)
        | <LT>  add() #LT(2)
        )*
}

private void add() :
{}
{
  mul() ( <Add> mul() #Add(2)
        | <Sub> mul() #Sub(2)
        )*
}

private void mul() :
{}
{
  unary() ( <Mul> unary() #Mul(2)
          | <Div> unary() #Div(2)
          | <Mod> unary() #Mod(2)
          )*
}

private void unary() :
{}
{
     <Sub> atom() #UnarySub
  |  <Not> atom() #Not
  |  atom()
}

private void atom() :
{}
{
     LOOKAHEAD(2)
     function()
  |  id()
  |  num()
  |  bool()
  |  <OParen> expr() <CParen>
}

private void function() #Function :
{}
{
    id() params()
}

private void num() #Num :
{
  Token t;
}
{
  t=<Number> {jjtThis.value = Double.valueOf(t.image);}
}

private void id() #Id :
{
  Token t;
}
{
  t=<Identifier> {jjtThis.value = t.image;}
}

private void bool() #Bool :
{
  Token t;
}
{
     <True>  {jjtThis.value = Boolean.TRUE;}
  |  <False> {jjtThis.value = Boolean.FALSE;}
}

private void params() :
{}
{
  <OParen> (expr() (<Comma> expr())*)? <CParen>
}

